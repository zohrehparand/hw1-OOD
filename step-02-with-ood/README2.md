srp: 
در گام سوم به دنبال رعایت کردن اصول سالید هستیم اولین اصل srp هست در این اصل ما  به کلاس reservationservice میرویم و این کلاس را به کلاس تک مسئولیتی تبدیل میکنیم برای همین تک به تک وظایف اضافی را از آن حذف می کنیم و کلاس هایی تحت عنوان کلاس های paymentservice,notifierservice  discountو invoiceservice اضافه می کنیم که کارهای مربوط به پرداخت، اطلاع رسانی، تخفیف و چاپ فاکتور را  انجام میدهند. 

ocp: 
در مرحله بعد به دنبال این هستیم که اصل ocp یا همان باز بودن برای توسعه سیستم و بسته بودن برای تغییرات را رعایت کنیم در کلاس paymentservice, discount و notifierservice مورد خطری که وجود داره این است که دارای سویچ کیس های مختلفی هستیم و برای اضافه کردن حالات مختلف خرید و نوتیفای کردن مجبوریم که تغییرات زیادی در کد ایجاد کنیم یا برای اضافه کردن شهر دیگه ای تخفیف باید حالات جدیدی به کد اضافه کنیم برای همین یک یک اینتر فیس discount درست می کنیم که کلاس که اینترفیس  citydiscount از آن ارث بری میکند و در آن تخفیف شهر پاریس را در نظر می گیریم بعد اینترفیس notifierservice  را می سازیم بعد از آن کلاس های emailnotifier و smsnotifer را درست می کنیم که از اینترفیس notifierserviceارث بری می کنند و  مسئولیت کارهای نوتیفای کردن را هر کدوم از این کلاس ها برعهده می گیرند. همین کار را مجددا برای کلاس paymentservice انجام میدهیم از آن یک اینترفیس می سازیم و کلاسهای روش های مختلف پرداخت را میسازیم را تا کلاس هایی باشن که از اینترفیس  ارث بری می کنند. در واقع در این اصل هر سوییچ کیس تبدیل به کلاس مجزایی میشود که از اینترفیس مربوطه ارثبری میکند. 


dip: 
برای رعایت اصل dip به وابستگی کلاسها دقت میکنیم و به دنبال new شدن شی جدید در کلاسها میگردیم . برای مثال در کلاسهایی شاهد new شدن اشیا از کلاس paymentprocessor هستیم. میتوانیم در این اصل این کلاس را حذف کنیم و در در کلاسهای مربوط به پرداخت میتوانید خط کد ایجاد شی را حذف کنیم و بدین ترتیب وابستگی را از بین ببریم.  و همینطور می توانیم کلاس های emailsenderو smssender را حذف کنیم و با کمک اصل dip وابستگی کلاس های emailnotifierو smsnotifier را به این کلاس  قطع کنیم. در واقع به جای ساخت شی داخل کلاس‌ها، وابستگی‌ها را از بیرون تزریق کردیم تا کلاس‌ها به abstraction وابسته باشند. 

اصول lsp  و isp با توجه به تغییرات به وجود امده در قسمت های بالا برقرار هستند و نیاز به تغییرات مجدد ندارند. 

plk: 
در اصل plk میخواهیم از chainهای طولانی مثل res.customer.getCity() جلوگیری کنیم و متدهای لازم را مستقیماً در کلاس Reservation قرار دهیم و در کلاس reservationservice آبجکتهایی که از آبجکتای کلاس های دیگر استفاده می کنند رو از بین ببریم برای همین در customer توابعی می سازیم که اسم، ایمیل، شهر، موبایل و پیامک را برمیگرداند و همین کار را برای کلاس های و luxuryroom و room انجام میدیم تا توابع قیمت ها، نوع اتاق، شماره اتاق و... را برگردانند و از آنها در  کلاس هایdiscount برای محاسبه تخفیف اتاق ها و reservation برای محاسبه قیمت وreservationservicr  استفاده می کنیم تا به جای اینکه آبجکتی از کلاس به آبجکتی از کلاس دیگر وصل باشه به متود آن وصل باشد. 
crp: 
کلاس های بلااستفاده بعد از اعمال اصول بالا حذف میشود و کلاسها در پکیج های مربوطه قرار میگیرند برای مثال تمام روش های پرداخت در پکیج payment قرار میگیرند و غیره.

اگر از مراحل ابتدایی اصول شی گرایی را رعایت میکردیم برای اضافه کردن پرداخت حضور باید یک کلاس (که از paymentservice ارثبری میکند)  میساختیم و نیاز به ایجاد تغییرات در کلاسهای payment processor و reservation service نبود که اینکار کد را بسیار ساده تر کرد و هماهنگی کد را بالا برد. 
و همینطور برای اضافه کردن پیامک به جای ساخت کلاس پیامک و ارثبری آن از messagesender و اضافه کردن متد بلا استفاده در این کلاس (sendemail) ایجاد تغییرات در reservation service و همینطور ایجاد کردن متد sendsms به کلاس messagesender میتوانیم با رعایت اصول شی گرایی بدون اینجاد تغییرات در اینترفیس notifierservice و email notfier و reservationservice تنها یک کلاس جدید اضافه کنیم که از notifierservice ارثبری میکند.


نتیجه: 
رعایت اصول شی گرایی کد را بسیار ساده تر و قابل فهم تر میکند. 
سرعت برنامه بالاتر رفته و اضافه کردن قابلیت های مختلف و اینجاد هماهنگی بین قسمت های مختلف برنامه بسیار ساده تر میشود.  
تست و بررسی برنامه ساده تر میشود بنابرین احتمال خطا کاهش یافته و سیستم پایدار تر میشود. 
مدیریت برنامه آسان تر میشود و مشکلات عملکردی زودتر تشخیص داده میشوند و طول عمر برنامه افزایش میابد چرا که کد نیاز کمتری به بازنویسی مجدد دارد و هزینه های تعمیر کد کم میشود. 
ارتباط و وابستگی کلاس ها نسبت به هم دیگر کم میشود و لازم نیست برای یک تغییر جزئی کلاس های مختلف را تغییر دهیم. 
در این برنامه میتوانیم با تغییرات اعمال شده وظیفه دقیق هر کلاس را متوجه شویم و به راحتی با کمترین تغییرات قابلیت های جدید اضافه کنیم.
